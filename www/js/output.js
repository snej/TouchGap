(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/www/js/app/config.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = module.exports = {t : {}},\n  mu = require(\"mustache\");\n\nconfig.dbHost = 'http://localhost.touchdb.';\n\nconfig.sync = 'http://animal.local:3000/channels/';\n\nconfig.syncTarget = 'animal.local:4984/basecouch';\n\nif (location.protocol != \"file:\") {\n  config.dbHost = location.origin;\n}\n\nconfig.dbUrl = config.dbHost + '/wiki';\n\n$('script[type=\"text/mustache\"]').each(function() {\n    var id = this.id.split('-');\n    id.pop();\n    module.exports.t[id.join('-')] = mu.compile(this.innerHTML.replace(/^\\s+|\\s+$/g,''));\n});\n\n//@ sourceURL=/www/js/app/config.js"
));

require.define("/node_modules/mustache/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./mustache.js\"}\n//@ sourceURL=/node_modules/mustache/package.json"
));

require.define("/node_modules/mustache/mustache.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\nvar Mustache;\n\n(function (exports) {\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = exports; // CommonJS\n  } else if (typeof define === \"function\") {\n    define(exports); // AMD\n  } else {\n    Mustache = exports; // <script>\n  }\n}((function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.1\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this.clearCache();\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.clearCache = function () {\n    this._cache = {};\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name === \".\") {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf(\".\") > 0) {\n            var names = name.split(\".\"), i = 0;\n\n            value = context.view;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) {\n            break;\n          }\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === \"function\") {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var fn = compileTokens(tokens);\n    var self = this;\n\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === \"function\") {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return fn(self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  Writer.prototype._section = function (name, context, text, callback) {\n    var value = context.lookup(name);\n\n    switch (typeof value) {\n    case \"object\":\n      if (isArray(value)) {\n        var buffer = \"\";\n\n        for (var i = 0, len = value.length; i < len; ++i) {\n          buffer += callback(this, context.push(value[i]));\n        }\n\n        return buffer;\n      }\n\n      return value ? callback(this, context.push(value)) : \"\";\n    case \"function\":\n      var self = this;\n      var scopedRender = function (template) {\n        return self.render(template, context);\n      };\n\n      var result = value.call(context.view, text, scopedRender);\n      return result != null ? result : \"\";\n    default:\n      if (value) {\n        return callback(this, context);\n      }\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._inverted = function (name, context, callback) {\n    var value = context.lookup(name);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0)) {\n      return callback(this, context);\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._partial = function (name, context) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    var fn = this._partialCache[name];\n\n    return fn ? fn(context) : \"\";\n  };\n\n  Writer.prototype._name = function (name, context) {\n    var value = context.lookup(name);\n\n    if (typeof value === \"function\") {\n      value = value.call(context.view);\n    }\n\n    return (value == null) ? \"\" : String(value);\n  };\n\n  Writer.prototype._escaped = function (name, context) {\n    return exports.escape(this._name(name, context));\n  };\n\n  /**\n   * Calculates the bounds of the section represented by the given `token` in\n   * the original template by drilling down into nested sections to find the\n   * last token that is part of that section. Returns an array of [start, end].\n   */\n  function sectionBounds(token) {\n    var start = token[3];\n    var end = start;\n\n    var tokens;\n    while ((tokens = token[4]) && tokens.length) {\n      token = tokens[tokens.length - 1];\n      end = token[3];\n    }\n\n    return [start, end];\n  }\n\n  /**\n   * Low-level function that compiles the given `tokens` into a function\n   * that accepts three arguments: a Writer, a Context, and the template.\n   */\n  function compileTokens(tokens) {\n    var subRenders = {};\n\n    function subRender(i, tokens, template) {\n      if (!subRenders[i]) {\n        var fn = compileTokens(tokens);\n        subRenders[i] = function (writer, context) {\n          return fn(writer, context, template);\n        };\n      }\n\n      return subRenders[i];\n    }\n\n    return function (writer, context, template) {\n      var buffer = \"\";\n      var token, sectionText;\n\n      for (var i = 0, len = tokens.length; i < len; ++i) {\n        token = tokens[i];\n\n        switch (token[0]) {\n        case \"#\":\n          sectionText = template.slice.apply(template, sectionBounds(token));\n          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));\n          break;\n        case \"^\":\n          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));\n          break;\n        case \">\":\n          buffer += writer._partial(token[1], context);\n          break;\n        case \"&\":\n          buffer += writer._name(token[1], context);\n          break;\n        case \"name\":\n          buffer += writer._escaped(token[1], context);\n          break;\n        case \"text\":\n          buffer += token[1];\n          break;\n        }\n      }\n\n      return buffer;\n    };\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have a fifth item: an array that contains\n   * all tokens in that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token, section;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case \"#\":\n      case \"^\":\n        token[4] = [];\n        sections.push(token);\n        collector.push(token);\n        collector = token[4];\n        break;\n      case \"/\":\n        if (sections.length === 0) {\n          throw new Error(\"Unopened section: \" + token[1]);\n        }\n\n        section = sections.pop();\n\n        if (section[1] !== token[1]) {\n          throw new Error(\"Unclosed section: \" + section[1]);\n        }\n\n        if (sections.length > 0) {\n          collector = sections[sections.length - 1][4];\n        } else {\n          collector = tree;\n        }\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    // Make sure there were no open sections when we're done.\n    section = sections.pop();\n\n    if (section) {\n      throw new Error(\"Unclosed section: \" + section[1]);\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var token, lastToken, squashedTokens = [];\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      if (lastToken && lastToken[0] === \"text\" && token[0] === \"text\") {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        lastToken = token;\n        squashedTokens.push(token);\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    if (tags.length !== 2) {\n      throw new Error(\"Invalid tags: \" + tags.join(\" \"));\n    }\n\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    template = template || '';\n    tags = tags || exports.tags;\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var tokens = [],      // Buffer to hold the tokens\n        spaces = [],      // Indices of whitespace tokens on the current line\n        hasTag = false,   // Is there a {{tag}} on the current line?\n        nonSpace = false; // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr;\n\n    while (!scanner.eos()) {\n      start = scanner.pos;\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([\"text\", chr, start, start + 1]);\n          start += 1;\n\n          if (chr === \"\\n\") {\n            stripSpace(); // Check for whitespace on the current line.\n          }\n        }\n      }\n\n      start = scanner.pos;\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) {\n        break;\n      }\n\n      hasTag = true;\n      type = scanner.scan(tagRe) || \"name\";\n\n      // Skip any whitespace between tag and value.\n      scanner.scan(whiteRe);\n\n      // Extract the tag value.\n      if (type === \"=\") {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === \"{\") {\n        var closeRe = new RegExp(\"\\\\s*\" + escapeRe(\"}\" + tags[1]));\n        value = scanner.scanUntil(closeRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = \"&\";\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error(\"Unclosed tag at \" + scanner.pos);\n      }\n\n      tokens.push([type, value, start, scanner.pos]);\n\n      if (type === \"name\" || type === \"{\" || type === \"&\") {\n        nonSpace = true;\n      }\n\n      // Set the tags for the next time around.\n      if (type === \"=\") {\n        tags = value.split(spaceRe);\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    tokens = squashTokens(tokens);\n\n    return nestTokens(tokens);\n  };\n\n  // The high-level clearCache, compile, compilePartial, and render functions\n  // use this default writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));\n\n//@ sourceURL=/node_modules/mustache/mustache.js"
));

require.define("/www/js/app/home.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = require('./config'),\n  auth = require('./auth'),\n  sync = require('./sync'),\n  mu = require(\"mustache\").render;\n\nexports.reload = function() {\n  location.hash=\"#/reloaded\";\n  location.reload()\n};\n\n// module.exports = function(route) {\n//   route(\"/home\", function() {\n//     // redirect to most recently updated wiki\n//     coux.get([config.dbUrl,\"_design\",\"wiki\",\"_view\",\"title\",\n//       {descending:true, limit:1}], function(err, view) {\n//         var id = (view.rows[0] && view.rows[0].id), path  = \"/wiki/\" + id;\n//         if (id) {\n//           console.log(\"redirect \"+path);\n//           route.go(path);\n//         } else {\n//           // no wikis, need to make a new one\n//           route.go(\"/edit/_new\");\n//         }\n//     });\n//   });\n\n//   route(\"/login\", function() {\n//     auth.getUser(function(no, user) {\n//       if (!no) {\n//         route.go(\"/home\");\n//       } else {\n//         $('#content').html(mu(config.t.login));\n//         $(\"#content form\").submit(function(e) {\n//           e.preventDefault();\n//           var me = $(\"input[type=text]\",this).val(),\n//             pass = $(\"input[type=password]\",this).val();\n//           auth.setUser({user : me, pass: pass}, function(err, ok) {\n//             if (err) throw err;\n//             ready(); // triggers initial sync\n//           });\n//         });\n//       }\n//     })\n//   });\n\n//   route(\"/start\", ready);\n\n//   function ready() {\n//     auth.getUser(function(no, user) {\n//       if (no) {\n//         route.go(\"/login\");\n//       } else {\n//         sync.trigger(user, function(err, ok) {\n//           if (err) {\n//             console.log(\"sync err\", err);\n//             route.go(\"/reset\");\n//           } else {\n//             route.begin(\"/home\");\n//           }\n//         });\n//       }\n//     });\n//   }\n\n//   return {ready:ready};\n// };\n\n\n//@ sourceURL=/www/js/app/home.js"
));

require.define("/www/js/app/auth.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = require(\"./config\");\n\nexports.setUser = function(user, cb) {\n  coux.put([config.dbUrl, \"_local/user\"], user, cb);\n};\n\nexports.getUser = function(cb) {\n  coux([config.dbUrl, \"_local/user\"], cb);\n};\n\n\n//@ sourceURL=/www/js/app/auth.js"
));

require.define("/www/js/app/sync.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = require(\"./config\");\n\n\nvar pullRep, pushRep,\n  pullPath = [config.dbHost, \"_replicator\", \"channel_pull\"],\n  pushPath = [config.dbHost, \"_replicator\", \"channel_push\"];\n\nfunction refreshSyncDoc(path, rep, cb) {\n  coux.get(path, function(err, ok) {\n    if (err) {\n      console.log(\"newdoc\", err, path);\n      // make a new doc\n      coux.put(path, rep, cb);\n    } else {\n      // delete it and make a new doc\n      var revpath = path.concat({rev:ok._rev})\n      console.log(\"deleting revpath\", revpath);\n      coux.del(revpath, function(err, ok) {\n        if (err) {\n          console.log(\"couldn't delete\", err, revpath)\n        }\n        coux.put(path, rep, cb);\n      })\n    }\n  });\n}\nfunction refreshSyncOnce(path, rep, cb) {\n  var cancel = JSON.parse(JSON.stringify(rep));\n  cancel.cancel = true;\n  coux.post([config.dbHost, \"_replicate\"], cancel, function() {\n    coux.post([config.dbHost, \"_replicate\"], rep, cb)\n  })\n}\nfunction refreshPush() {\n  var doSync = false ? refreshSyncDoc : refreshSyncOnce;\n  doSync(pushPath, pushRep, function(err, ok) {\n    // console.log(\"pushRep\", err, ok)\n  })\n}\nfunction refreshPull() {\n  var doSync = false ? refreshSyncDoc : refreshSyncOnce;\n  doSync(pullPath, pullRep, function(err, ok) {\n    // console.log(\"pullRep\", err, ok)\n  })\n}\nfunction syncTheseChannels(user, channels) {\n  if (!(channels && channels.length)) return;\n    pullRep = {\n      source : \"http://\"+user.user+\":\"+user.pass+\"@\"+config.syncTarget,\n      target : \"wiki\",\n      continuous : true,\n      filter : \"basecouch/bychannel\",\n      query_params : {\n          channels : channels.join(',')\n      }\n    };\n    pushRep = {\n        target : \"http://\"+user.user+\":\"+user.pass+\"@\"+config.syncTarget,\n        source : \"wiki\",\n        continuous : true\n    };\n    refreshPush()\n    refreshPull()\n}\n\n\nvar syncInterval = false;\nfunction syncForUser(userDoc, cb) {\n  if (!syncInterval) {\n    syncInterval = setInterval(function() {\n      syncForUser(userDoc);\n    },10000);\n  }\n\n  // console.log(\"syncForUser\", userDoc.user);\n                            // silly cache\n  coux.post(config.sync+'?r='+Math.random(), userDoc, function(err, channels) {\n      if (err) console.log(\"ch err\", err);\n      console.log([\"channels\", channels]);\n      if (cb) {cb(err, channels);}\n      syncTheseChannels(userDoc, channels);\n  });\n};\n\nexports.trigger = syncForUser;\n\n\n\n//@ sourceURL=/www/js/app/sync.js"
));

require.define("/www/js/app/jsonform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = function(elem) {\n  var o = {}, list = $(elem).serializeArray();\n  for (var i = list.length - 1; i >= 0; i--) {\n    var name = list[i].name, value = list[i].value;\n    if (o[name]) {\n        if (!o[name].push) {\n            o[name] = [o[name]];\n        }\n        o[name].push(value);\n    } else {\n        o[name] = value;\n    }\n  };\n  return o;\n};\n\n\n\n//@ sourceURL=/www/js/app/jsonform.js"
));

require.define("/www/js/touchlink.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nmodule.exports = function(root, classname) {\n  classname = classname || \"touch\";\n  var events = [\n    [\"click\",\"removeClass\"],\n    [\"touchstart\",\"addClass\"],\n    [\"touchend\",\"removeClass\"]\n  ];\n  for (var i = events.length - 1; i >= 0; i--) {\n    var on = events[i][0], method = events[i][1];\n    $(root).on(on,\"a\",function(e) {\n      var target = $(e.currentTarget);\n      if (target.attr('href')) {\n        target[method](classname);\n      }\n    });\n  };\n};\n\n//@ sourceURL=/www/js/touchlink.js"
));

require.define("/node_modules/fastclick/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/fastclick.js\"}\n//@ sourceURL=/node_modules/fastclick/package.json"
));

require.define("/node_modules/fastclick/lib/fastclick.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/**\n * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\n *\n * @version 0.4.5\n * @codingstandard ftlabs-jsv2\n * @copyright The Financial Times Limited [All Rights Reserved]\n * @license MIT License (see LICENSE.txt)\n */\n\n/*jslint browser:true, node:true*/\n/*global define*/\n\n\n/**\n * Instantiate fast-clicking listeners on the specificed layer.\n *\n * @constructor\n * @param {Element} layer The layer to listen on\n */\nfunction FastClick(layer) {\n\t'use strict';\n\tvar oldOnClick, self = this;\n\n\n\t/**\n\t * Whether a click is currently being tracked.\n\t *\n\t * @type boolean\n\t */\n\tthis.trackingClick = false;\n\n\n\t/**\n\t * Timestamp for when when click tracking started.\n\t *\n\t * @type number\n\t */\n\tthis.trackingClickStart = 0;\n\n\n\t/**\n\t * The element being tracked for a click.\n\t *\n\t * @type EventTarget\n\t */\n\tthis.targetElement = null;\n\n\n\t/**\n\t * X-coordinate of touch start event.\n\t *\n\t * @type number\n\t */\n\tthis.touchStartX = 0;\n\n\n\t/**\n\t * Y-coordinate of touch start event.\n\t *\n\t * @type number\n\t */\n\tthis.touchStartY = 0;\n\n\n\t/**\n\t * The FastClick layer.\n\t *\n\t * @type Element\n\t */\n\tthis.layer = layer;\n\n\tif (!layer || !layer.nodeType) {\n\t\tthrow new TypeError('Layer must be a document node');\n\t}\n\n\t/** @type function() */\n\tthis.onClick = function() { FastClick.prototype.onClick.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchStart = function() { FastClick.prototype.onTouchStart.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchMove = function() { FastClick.prototype.onTouchMove.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchEnd = function() { FastClick.prototype.onTouchEnd.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchCancel = function() { FastClick.prototype.onTouchCancel.apply(self, arguments); };\n\n\t// Devices that don't support touch don't need FastClick\n\tif (typeof window.ontouchstart === 'undefined') {\n\t\treturn;\n\t}\n\n\t// Set up event handlers as required\n\tlayer.addEventListener('click', this.onClick, true);\n\tlayer.addEventListener('touchstart', this.onTouchStart, false);\n\tlayer.addEventListener('touchmove', this.onTouchMove, false);\n\tlayer.addEventListener('touchend', this.onTouchEnd, false);\n\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\n\n\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\n\t// layer when they are cancelled.\n\tif (!Event.prototype.stopImmediatePropagation) {\n\t\tlayer.addEventListener = function(type, callback, capture) {\n\t\t\tNode.prototype.addEventListener.call(layer, type, function(event) {\n\t\t\t\tif (!event.propagationStopped) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, capture);\n\t\t};\n\t}\n\n\t// If a handler is already declared in the element's onclick attribute, it will be fired before\n\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\n\t// adding it as listener.\n\tif (typeof layer.onclick === 'function') {\n\n\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\n\t\t// - the old one won't work if passed to addEventListener directly.\n\t\toldOnClick = layer.onclick;\n\t\tlayer.addEventListener('click', function(event) {\n\t\t\toldOnClick(event);\n\t\t}, false);\n\t\tlayer.onclick = null;\n\t}\n}\n\n\n/**\n * Android requires an exception for labels.\n *\n * @type boolean\n */\nFastClick.prototype.deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;\n\n\n/**\n * Determine whether a given element requires a native click.\n *\n * @param {EventTarget|Element} target Target DOM element\n * @returns {boolean} Returns true if the element needs a native click\n */\nFastClick.prototype.needsClick = function(target) {\n\t'use strict';\n\tswitch (target.nodeName.toLowerCase()) {\n\tcase 'label':\n\tcase 'video':\n\t\treturn true;\n\tdefault:\n\t\treturn (/\\bneedsclick\\b/).test(target.className);\n\t}\n};\n\n\n/**\n * Determine whether a given element requires a call to focus to simulate click into element.\n *\n * @param {EventTarget|Element} target Target DOM element\n * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\n */\nFastClick.prototype.needsFocus = function(target) {\n\t'use strict';\n\tswitch (target.nodeName.toLowerCase()) {\n\tcase 'textarea':\n\tcase 'select':\n\t\treturn true;\n\tcase 'input':\n\t\tswitch (target.type) {\n\t\tcase 'button':\n\t\tcase 'checkbox':\n\t\tcase 'file':\n\t\tcase 'image':\n\t\tcase 'radio':\n\t\tcase 'submit':\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\treturn (/\\bneedsfocus\\b/).test(target.className);\n\t}\n};\n\n\n/**\n * Send a click event to the specified element.\n *\n * @param {EventTarget|Element} targetElement\n * @param {Event} event\n */\nFastClick.prototype.sendClick = function(targetElement, event) {\n\t'use strict';\n\tvar clickEvent, touch;\n\n\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\n\tif (document.activeElement && document.activeElement !== targetElement) {\n\t\tdocument.activeElement.blur();\n\t}\n\n\ttouch = event.changedTouches[0];\n\n\t// Synthesise a click event, with an extra attribute so it can be tracked\n\tclickEvent = document.createEvent('MouseEvents');\n\tclickEvent.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n\tclickEvent.forwardedTouchEvent = true;\n\ttargetElement.dispatchEvent(clickEvent);\n};\n\n\n/**\n * On touch start, record the position and scroll offset.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchStart = function(event) {\n\t'use strict';\n\tvar touch = event.targetTouches[0];\n\n\tthis.trackingClick = true;\n\tthis.trackingClickStart = event.timeStamp;\n\tthis.targetElement = event.target;\n\n\tthis.touchStartX = touch.pageX;\n\tthis.touchStartY = touch.pageY;\n\n\t// Prevent phantom clicks on fast double-tap (issue #36)\n\tif ((event.timeStamp - this.lastClickTime) < 200) {\n\t\tevent.preventDefault();\n\t}\n\n\treturn true;\n};\n\n\n/**\n * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.touchHasMoved = function(event) {\n\t'use strict';\n\tvar touch = event.targetTouches[0];\n\n\tif (Math.abs(touch.pageX - this.touchStartX) > 10 || Math.abs(touch.pageY - this.touchStartY) > 10) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n\n/**\n * Update the last position.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchMove = function(event) {\n\t'use strict';\n\tif (!this.trackingClick) {\n\t\treturn true;\n\t}\n\n\t// If the touch has moved, cancel the click tracking\n\tif (this.targetElement !== event.target || this.touchHasMoved(event)) {\n\t\tthis.trackingClick = false;\n\t\tthis.targetElement = null;\n\t}\n\n\treturn true;\n};\n\n\n/**\n * Attempt to find the labelled control for the given label element.\n *\n * @param {EventTarget|HTMLLabelElement} labelElement\n * @returns {Element|null}\n */\nFastClick.prototype.findControl = function(labelElement) {\n\t'use strict';\n\n\t// Fast path for newer browsers supporting the HTML5 control attribute\n\tif (labelElement.control !== undefined) {\n\t\treturn labelElement.control;\n\t}\n\n\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\n\tif (labelElement.htmlFor) {\n\t\treturn document.getElementById(labelElement.htmlFor);\n\t}\n\n\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\n\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\n\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\n};\n\n\n/**\n * On touch end, determine whether to send a click event at once.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchEnd = function(event) {\n\t'use strict';\n\tvar forElement, trackingClickStart, targetElement = this.targetElement;\n\n\tif (!this.trackingClick) {\n\t\treturn true;\n\t}\n\n\t// Prevent phantom clicks on fast double-tap (issue #36)\n\tif ((event.timeStamp - this.lastClickTime) < 200) {\n\t\tthis.cancelNextClick = true;\n\t\treturn true;\n\t}\n\n\tthis.lastClickTime = event.timeStamp;\n\n\ttrackingClickStart = this.trackingClickStart;\n\tthis.trackingClick = false;\n\tthis.trackingClickStart = 0;\n\n\tif (targetElement.nodeName.toLowerCase() === 'label') {\n\t\tforElement = this.findControl(targetElement);\n\t\tif (forElement) {\n\t\t\ttargetElement.focus();\n\t\t\tif (this.deviceIsAndroid) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.needsClick(forElement)) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.sendClick(forElement, event);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t} else if (this.needsFocus(targetElement)) {\n\n\t\t// If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\n\t\tif ((event.timeStamp - trackingClickStart) > 100) {\n\t\t\tthis.targetElement = null;\n\t\t\treturn true;\n\t\t}\n\n\t\ttargetElement.focus();\n\n\t\t// Select elements need the event to go through at least on iOS, otherwise the selector menu won't open.\n\t\tif (targetElement.tagName.toLowerCase() !== 'select') {\n\t\t\tthis.targetElement = null;\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Prevent the actual click from going though - unless the target node is marked as requiring\n\t// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.\n\tif (!this.needsClick(targetElement)) {\n\t\tevent.preventDefault();\n\t\tthis.sendClick(targetElement, event);\n\t}\n\n\treturn false;\n};\n\n\n/**\n * On touch cancel, stop tracking the click.\n *\n * @returns {void}\n */\nFastClick.prototype.onTouchCancel = function() {\n\t'use strict';\n\tthis.trackingClick = false;\n\tthis.targetElement = null;\n};\n\n\n/**\n * On actual clicks, determine whether this is a touch-generated click, a click action occurring\n * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\n * an actual click which should be permitted.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onClick = function(event) {\n\t'use strict';\n\n\tvar oldTargetElement;\n\n\t// If a target element was never set (because a touch event was never fired) allow the click\n\tif (!this.targetElement) {\n\t\treturn true;\n\t}\n\n\tif (event.forwardedTouchEvent) {\n\t\treturn true;\n\t}\n\n\toldTargetElement = this.targetElement;\n\tthis.targetElement = null;\n\n\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\n\tif (this.trackingClick) {\n\t\tthis.trackingClick = false;\n\t\treturn true;\n\t}\n\n\t// Programmatically generated events targeting a specific element should be permitted\n\tif (!event.cancelable) {\n\t\treturn true;\n\t}\n\n\t// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\n\tif (event.target.type === 'submit' && event.detail === 0) {\n\t\treturn true;\n\t}\n\n\t// Derive and check the target element to see whether the click needs to be permitted;\n\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\n\t// to prevent ghost/doubleclicks.\n\tif (!this.needsClick(oldTargetElement) || this.cancelNextClick) {\n\t\tthis.cancelNextClick = false;\n\n\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\n\t\tif (event.stopImmediatePropagation) {\n\t\t\tevent.stopImmediatePropagation();\n\t\t} else {\n\n\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t\tevent.propagationStopped = true;\n\t\t}\n\n\t\t// Cancel the event\n\t\tevent.stopPropagation();\n\t\tevent.preventDefault();\n\n\t\treturn false;\n\t}\n\n\t// If clicks are permitted, return true for the action to go through.\n\treturn true;\n};\n\n\n/**\n * Remove all FastClick's event listeners.\n *\n * @returns {void}\n */\nFastClick.prototype.destroy = function() {\n\t'use strict';\n\tvar layer = this.layer;\n\n\tlayer.removeEventListener('click', this.onClick, true);\n\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\n\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\n\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\n\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\n};\n\n\nif (typeof define !== 'undefined' && define.amd) {\n\n\t// AMD. Register as an anonymous module.\n\tdefine(function() {\n\t\t'use strict';\n\t\treturn FastClick;\n\t});\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = function(layer) {\n\t\t'use strict';\n\t\treturn new FastClick(layer);\n\t};\n\n\tmodule.exports.FastClick = FastClick;\n}\n\n//@ sourceURL=/node_modules/fastclick/lib/fastclick.js"
));

require.define("/node_modules/routes/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/routes/package.json"
));

require.define("/node_modules/routes/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar localRoutes = [];\n\n\n/**\n * Convert path to route object\n *\n * A string or RegExp should be passed,\n * will return { re, src, keys} obj\n *\n * @param  {String / RegExp} path\n * @return {Object}\n */\n \nvar Route = function(path){\n  //using 'new' is optional\n  \n  var src, re, keys = [];\n  \n  if(path instanceof RegExp){\n    re = path;\n    src = path.toString();\n  }else{\n    re = pathToRegExp(path, keys);\n    src = path;\n  }\n\n  return {\n  \t re: re,\n  \t src: path.toString(),\n  \t keys: keys\n  }\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String} path\n * @param  {Array} keys\n * @return {RegExp}\n */\nvar pathToRegExp = function (path, keys) {\n\tpath = path\n\t\t.concat('/?')\n\t\t.replace(/\\/\\(/g, '(?:/')\n\t\t.replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n\t\t\tkeys.push(key);\n\t\t\tslash = slash || '';\n\t\t\treturn ''\n\t\t\t\t+ (optional ? '' : slash)\n\t\t\t\t+ '(?:'\n\t\t\t\t+ (optional ? slash : '')\n\t\t\t\t+ (format || '') + (capture || '([^/]+?)') + ')'\n\t\t\t\t+ (optional || '');\n\t\t})\n\t\t.replace(/([\\/.])/g, '\\\\$1')\n\t\t.replace(/\\*/g, '(.+)');\n\treturn new RegExp('^' + path + '$', 'i');\n};\n\n/**\n * Attempt to match the given request to\n * one of the routes. When successful\n * a  {fn, params, splats} obj is returned\n *\n * @param  {Array} routes\n * @param  {String} uri\n * @return {Object}\n */\nvar match = function (routes, uri) {\n\tvar captures, i = 0;\n\n\tfor (var len = routes.length; i < len; ++i) {\n\t\tvar route = routes[i],\n\t\t    re = route.re,\n\t\t    keys = route.keys,\n\t\t    splats = [],\n\t\t    params = {};\n\n\t\tif (captures = re.exec(uri)) {\n\t\t\tfor (var j = 1, len = captures.length; j < len; ++j) {\n\t\t\t\tvar key = keys[j-1],\n\t\t\t\t\tval = typeof captures[j] === 'string'\n\t\t\t\t\t\t? decodeURIComponent(captures[j])\n\t\t\t\t\t\t: captures[j];\n\t\t\t\tif (key) {\n\t\t\t\t\tparams[key] = val;\n\t\t\t\t} else {\n\t\t\t\t\tsplats.push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tparams: params,\n\t\t\t\tsplats: splats,\n\t\t\t\troute: route.src\n\t\t\t};\n\t\t}\n\t}\n};\n\n/**\n * Default \"normal\" router constructor.\n * accepts path, fn tuples via addRoute\n * returns {fn, params, splats, route}\n *  via match\n *\n * @return {Object}\n */\n \nvar Router = function(){\n  //using 'new' is optional\n  return {\n    routes: [],\n    routeMap : {},\n    addRoute: function(path, fn){\n      if (!path) throw new Error(' route requires a path');\n      if (!fn) throw new Error(' route ' + src + ' requires a callback');\n\n      var route = Route(path);\n      route.fn = fn;\n\n      this.routes.push(route);\n      this.routeMap[path] = fn;\n    },\n\n    match: function(pathname){\n      var route = match(this.routes, pathname);\n      if(route){\n        route.fn = this.routeMap[route.route];\n      }\n      return route;\n    }\n  }\n};\n\nmodule.exports = {\n  Route: Route,\n  pathToRegExp: pathToRegExp,\n  match: match,\n  Router: Router\n}\n//@ sourceURL=/node_modules/routes/index.js"
));

require.define("/www/js/app/chat.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var auth = require(\"./auth\"),\n  config = require(\"./config\"),\n  // db = coux.prefix(config.dbUrl),\n  // view = coux.prefix([config.dbUrl,\"_design\",\"wiki\",\"_view\",\"title\"]),\n\n  jsonform = require(\"./jsonform\");\n\nexports.view = function(id) {\n  console.log(\"view chat\", id)\n  // db.get(id, function() {});\n  coux.get([config.dbUrl, id], function(err, chat) {\n    console.log(\"chat\", chat)\n  });\n};\n\nexports.index = function() {\n  console.log(\"list chats\")\n  coux.get([config.dbUrl,\"_design\",\"chat\",\"_view\",\"title\"], function(err, view) {\n    console.log(err, view);\n  });\n};\n\n\nexports.create = function() {\n  console.log(\"new chat\", this)\n  auth.getUser(function(err, user) {\n    if (err) {\n      location.hash = \"#/reload\";\n      return;\n    };\n    $(\"#content\").html(config.t.newChat(user));\n    $(\"#content form\").submit(function(e) {\n      e.preventDefault();\n      var doc = jsonform(this);\n      doc.created_at = doc.updated_at = new Date();\n      doc._id = doc.chat_id = Math.random().toString(20).slice(2);\n      doc.type = \"chat\";\n      // db.post(doc, function(err, ok) {});\n      coux.post(config.dbUrl, doc, function(err, ok) {\n        console.log(err, ok);\n        location.hash = \"#/chat/\"+ok.id;\n      });\n      return false;\n    });\n  });\n};\n\n//@ sourceURL=/www/js/app/chat.js"
));

require.define("/www/js/routes-element.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var routes = require(\"routes\");\n\nmodule.exports = function(table, element, bubbles) {\n  var match = matcherForTable(table, element);\n  $(window).bind('hashchange', function(){\n    match(location.hash);\n  });\n  $(document.body).on(\"click\", \"a\", function() {\n    var url = this.href,\n      path = url.slice(url.indexOf('#')),\n      matched = match(path);\n    // if bubbles is == false, the #/hash won't change, useful for\n    // state that doesn't need to be linkable or in the history\n    if (matched) return bubbles;\n  });\n  return {\n    init : function(path) {\n      console.log(\"init\", location.hash||path)\n      match(location.hash||path||\"/\");\n    },\n    go : function(path) { // for non-linked state on widgets\n      match(path);\n    }\n  }\n};\n\nfunction matcherForTable(table, element) {\n  var router = new routes.Router();\n  for (var path in table) {\n    if (table[path]) {\n      console.log(\"bind route\", path)\n      router.addRoute(path, function() {\n        console.log(\"run\", element, path, arguments, table[path])\n        table[path].apply(element, arguments);\n      }); // ensure this is the element\n    }\n  }\n  return function(path) {\n    console.log(\"try\",path.replace(/^#/,''));\n    matched = router.match(path.replace(/^#/,''));\n    if (matched) {\n      matched.fn(matched)\n    }\n  }\n};\n\n\n\n\n//@ sourceURL=/www/js/routes-element.js"
));

require.define("/www/js/app.js",Function(['require','module','exports','__dirname','__filename','process','global'],"$(function() {\n  var config = require('./app/config'),\n    home = require(\"./app/home\"),\n    chat = require(\"./app/chat\"),\n\n    // libraries\n    touchlink = require(\"./touchlink\"),\n    fastclick = require(\"fastclick\"),\n    router = require(\"./routes-element\");\n    // router = require('director').Router;\n\n  new fastclick.FastClick(document.body);\n\n  var content = $(\"#content\")[0],\n    contentRoutes = {\n      \"/login\" : home.login,\n      \"/reload\" : home.reload,\n      \"/\" : home.start,\n      // \"/chats/new\" : chat.create\n      \"/chat/:id\" : chat.view\n\n    },\n    sidebar = $(\"#sidebar\")[0],\n    sidebarRoutes = {\n      \"/chats\" : chat.index\n    };\n\n  touchlink(sidebar);\n\n  var contentRouter = router(contentRoutes, content);\n  contentRouter.init();\n  console.log(\"contentRouter\", contentRouter)\n  // // var sidebarRouter = router(sidebarRoutes, sidebar);\n\n\n\n  //   auth = require('./app/auth'),\n  //   // sync = require('./app/sync'),\n  //   // register controllers\n  //   home = require(\"./app/home\")(route),\n  //   wikis = require(\"./app/wikis\")(route),\n  //   edits = require(\"./app/edits\")(route),\n  //   sidebar = require(\"./app/sidebar\")(route);\n\n  // home.ready();\n  // sidebar.draw();\n\n  // coux.changes(config.dbUrl, function(err, changes) {\n  //     console.log(\"change\", err, changes);\n  //     sidebar.draw();\n\n  //     var matches = window.location.toString().match(/^[^#]*#(.+)$/);\n  //     if (matches && matches[1] && !/edit/.test(matches[1])) {\n  //         route.go(matches[1])\n  //     }\n  // });\n\n});\n\n\n//@ sourceURL=/www/js/app.js"
));
require("/www/js/app.js");
})();
